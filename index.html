<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - terrain</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="plot"></div>

		<script src="js/three.js"></script>

		<script src="js/OrbitControls.js"></script>
		<script src="js/TrackballControls.js"></script>

 		<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
		<script src="js/d3.v4.min.js"></script>
		<script>

		class surface_scene {
			constructor(dom_target = "plot", controls = "trackball"){
				this.dom_target = dom_target;
				this.width = window.innerWidth;
				this.height = window.innerHeight;
				this.current_objects = [];

				this.initialize_scene();
				this.initialize_camera();
				this.initialize_renderer();
				this.initialize_lights();

				if(controls === "trackball"){
					this.initialize_trackball_controls();
				} else {
					this.initialize_orbit_controls();
				}

				this.animate();
			}

			initialize_scene(){
                console.log("initializing scene")
                //Grab the dom element we are using to store this visualization.
                this.container = document.getElementById( this.dom_target );

				//This is a holder for all our plot surfaces
                this.suface_plot = new THREE.Object3D();

                //set up the 3d 'scene' for three to render.
                this.scene = new THREE.Scene();

				// window.scene = this.scene; //debugging
            }

			initialize_camera(){
                console.log("initializing camera")
                //Setup the camera.
                this.camera = new THREE.PerspectiveCamera( 60, this.width / this.height, 1, 1000 );

		        this.camera.position.x = 0;
		        this.camera.position.y = -8;
		        this.camera.position.z = -4;
            }

			initialize_renderer(){
                console.log("initializing renderer")

				//Set up the renderer
				var renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( this.width, this.height);
				this.container.innerHTML = "";
				//send to the container
				this.container.appendChild( renderer.domElement );

				this.renderer = renderer;

                this.render = () => this.renderer.render( this.scene, this.camera )
            }

			initialize_lights(){
				console.log("initializing lights")
				//Light below scene
				var light1 = new THREE.PointLight(0xffffff);
				light1.position.set(0,0,-100);
				this.scene.add(light1);

				//light above scene
				var light2 = new THREE.PointLight(0xffffff);
				light2.position.set(0,0,100);
				this.scene.add(light2);
			}

			initialize_orbit_controls(){
                console.log("initializing the controls")

				//Controls
				this.controls = new THREE.OrbitControls( this.camera, this.container );
				this.controls.addEventListener( 'change', this.render ); // remove when using animation loop

                //add event listeners to html for custom zooming and node selection.
                window.addEventListener( 'resize', this.onWindowResize.bind(this), false );
            }

			initialize_trackball_controls(){
                console.log("initializing the controls")

				var controls = new THREE.TrackballControls( this.camera );
				controls.rotateSpeed = 3.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 1.5;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				controls.keys = [ 65, 83, 68 ];

				this.controls = controls;
				this.controls.addEventListener( 'change', this.render );

				// add event listeners to html for custom zooming and node selection.
                window.addEventListener( 'resize', this.onWindowResize.bind(this), false );
            }

			onWindowResize() {
				console.log("resizing")
				this.width = window.innerWidth;
				this.height = document.getElementById(this.dom_target).offsetHeight;

                this.camera.aspect = this.width / this.height;
                this.camera.lookAt(this.scene.position);
                this.camera.updateProjectionMatrix();
                this.renderer.setSize( this.width, this.height );
            }

            animate() {
                requestAnimationFrame( this.animate.bind(this) );
                this.controls.update();
                this.render();

				this.current_objects.forEach((obj) => {
					obj.update_func();
				})
            }

			//takes an object and adds it to the scene.
			add_object( object ){
				this.current_objects.push(object);
				this.scene.add( object.object );

				// object.update_func.start();
				console.log(this.current_objects)
			}

			print_scene(){
				console.log(this.scene);
			}
		}

		//draw a simple surface from a json imput containing the fields
		//x y and z.
		class simpleSurface{
			constructor(data, x = "x", y = "y", z = "z", color = "steelblue", wireframe = false){

				Array.prototype.unique = function() {
				    var arr = [];
				    for(var i = 0; i < this.length; i++) {
				        if(!arr.includes(this[i])) {
				            arr.push(this[i]);
				        }
				    }
				    return arr;
				}

				this.duplicate_array = function(arr){
					var new_array = new Float32Array(arr.length);

					var i = arr.length;
					while(i--) new_array[i] = arr[i];
					return new_array;
				}

				//grab some info about the data.
				this.x_range  = d3.extent(data, d => +d[x]);
				this.x_width  = this.x_range[1] - this.x_range[0];
				this.y_range  = d3.extent(data, d => +d[y]);
				this.y_width  = this.y_range[1] - this.y_range[0];
				this.z_range  = d3.extent(data, d => +d[z]);
				this.unique_x = data.map(d => +d[x]).unique().length;
				this.unique_y = data.map(d => +d[y]).unique().length;

				this.data = data;
				this.z = z; //so we know what to target in the data object later.


				this.make_geometry();
				this.make_material(color, wireframe);
				this.combine();
				this.make_update_func();
			}

			make_geometry(){

				// geometry of surface
				var geometry = new THREE.PlaneBufferGeometry(this.x_width, this.y_width,
					this.unique_x - 1, this.unique_y - 1);

				this.displacement = new Float32Array( geometry.attributes.position.count );


				for (var v = 0; v < this.displacement; v++) {
				  this.displacement.push(Math.random() * 30);
				}
				//spits out an array of (x,y,z = 0) times the number of points we have.
				this.vertices = geometry.attributes.position.array;

				//create two duplicate arrays of verts array for later tweening.
				this.new_verticies = this.duplicate_array(this.vertices);

				//fill in the z coordinates with our data
				for ( var i = 0; i < this.data.length; i ++) this.new_verticies[(3*i) +2] = +this.data[i][this.z]*3;
				// for ( var i = 0; i < this.data.length; i ++) vertices[(3*i) +2] = +this.data[i][this.z]*3;

				geometry.attributes.position.array = this.new_verticies;
				//send our attributes to the geometry

				geometry.addAttribute( 'displacement', new THREE.BufferAttribute( this.displacement, 1 ) );
				geometry.addAttribute( 'end_verts', new THREE.BufferAttribute( this.new_verticies , 1 ) );
				this.geometry = geometry;
			}

			make_material(color, wireframe){

				var vertexShader = `uniform float amplitude;
									attribute float displacement;
									attribute vec3 end_verts;

									varying vec3 vNormal;
									varying vec2 vUv;

									void main() {
										vNormal = normal;
										vec3 newPosition = position + normal;
										gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
									}`;

				var fragmentShader = `uniform vec3 color;
									  uniform vec3 diffuse;

									  varying vec3 vNormal;
									  varying vec2 vUv;

									  void main() {
									  	  vec3 light = vec3(0.5, 0.2, 1.0);
									  	  light = normalize( light );
										  float dProd = max(0.0,dot(vNormal, light));
				  						  gl_FragColor = vec4(dProd,  // R
				  						                      dProd,  // G
				  						                      dProd,  // B
				  						                      1.0); // A
									  }`


				this.uniforms = THREE.UniformsUtils.merge(
			        [ THREE.UniformsLib['lights'],
					  THREE.UniformsLib["ambient"],

			        {
			          diffuse: {type: 'c', value: new THREE.Color(0x0000ff)},
					  amplitude: { value: 1.0 },
  					  color:     { value: new THREE.Color( 0xff2200 ) }
			        }
			        ]
			    )

				console.log(this.uniforms)

				var mat = new THREE.ShaderMaterial({
		            uniforms: this.uniforms,
		            vertexShader: vertexShader,
		            fragmentShader: fragmentShader,
					lights: true
		        });

				var surface_color = new THREE.Color(color);
				//material of surface
				var material = new THREE.MeshPhongMaterial({
					   color: surface_color,
					   specular: 0x0,
					   shading: THREE.FlatShading,
					   side: THREE.DoubleSide,
					   wireframe:wireframe
				});
				// this.material = material;
				this.material = mat;

			}

			combine(){
				//put together geometry and material
				var mesh = new THREE.Mesh( this.geometry, this.material );
				this.surface_object = mesh;
			}

			//if we are tweening let's generate an update function to be called.
			make_update_func(){
				this.update_func = () => {
					var time = Date.now() * 0.001;
					for ( var i = 0; i < this.displacement.length; i ++ ) {
						this.displacement[ i ] = Math.sin( 0.1 * i );
					}

					this.surface_object.geometry.attributes.displacement.needsUpdate = true;
				}

			}

			//function to return object when called for.
			object(){
				return {
					object: this.surface_object,
					update_func: this.update_func
				};
			}
		}

		//set up the scene and append to the page
		var three_scene = new surface_scene("plot");

		// d3.csv("data/knn_surface.csv", data => {
		// 	//create a simple surface from our data and render it to our scene.
		// 	var my_surface = new simpleSurface(data, x = "x", y = "y", z = "z", color = "steelblue", wireframe = false);
		//
		// 	//add the object to the scene.
		// 	three_scene.add_object(my_surface.object())
		// });

		d3.csv("data/bayes_surface.csv", data => {
			//create a simple surface from our data and render it to our scene.
			var my_surface = new simpleSurface(data, x = "x", y = "y", z = "z", color = "orangered", wireframe = true);

			//add the object to the scene.
			three_scene.add_object(my_surface.object())
		});



		</script>

	</body>
</html>
