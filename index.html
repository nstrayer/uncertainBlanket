<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - terrain</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="plot"></div>

		<script src="js/three.js"></script>

		<script src="js/OrbitControls.js"></script>
		<script src="js/TrackballControls.js"></script>

 		<script src="js/Detector.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="js/d3.v4.min.js"></script>
		<script>

		class surface_scene {
			constructor(dom_target = "plot", controls = "trackball"){
				this.dom_target = dom_target;
				this.width = window.innerWidth;
				this.height = window.innerHeight;

				this.initialize_scene();
				this.initialize_camera();
				this.initialize_renderer();
				this.initialize_lights();

				if(controls === "trackball"){
					this.initialize_trackball_controls();
				} else {
					this.initialize_orbit_controls();
				}

				this.animate();
			}

			initialize_scene(){
                console.log("initializing scene")
                //Grab the dom element we are using to store this visualization.
                this.container = document.getElementById( this.dom_target );

				//This is a holder for all our plot surfaces
                this.suface_plot = new THREE.Object3D();

                //set up the 3d 'scene' for three to render.
                this.scene = new THREE.Scene();

				// window.scene = this.scene; //debugging
            }

			initialize_camera(){
                console.log("initializing camera")
                //Setup the camera.
                this.camera = new THREE.PerspectiveCamera( 60, this.width / this.height, 1, 1000 );

		        this.camera.position.x = 0;
		        this.camera.position.y = -8;
		        this.camera.position.z = -4;
            }

			initialize_renderer(){
                console.log("initializing renderer")

				//Set up the renderer
				var renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( this.width, this.height);
				this.container.innerHTML = "";
				//send to the container
				this.container.appendChild( renderer.domElement );

				this.renderer = renderer;

                this.render = () => this.renderer.render( this.scene, this.camera )
            }

			initialize_lights(){
				console.log("initializing lights")
				//Light below scene
				var light1 = new THREE.PointLight(0xffffff);
				light1.position.set(0,0,-100);
				this.scene.add(light1);

				//light above scene
				var light2 = new THREE.PointLight(0xffffff);
				light2.position.set(0,0,100);
				this.scene.add(light2);
			}

			initialize_orbit_controls(){
                console.log("initializing the controls")

				//Controls
				this.controls = new THREE.OrbitControls( this.camera, this.container );
				this.controls.addEventListener( 'change', this.render ); // remove when using animation loop

                //add event listeners to html for custom zooming and node selection.
                window.addEventListener( 'resize', this.onWindowResize.bind(this), false );
            }

			initialize_trackball_controls(){
                console.log("initializing the controls")

				var controls = new THREE.TrackballControls( this.camera );
				controls.rotateSpeed = 3.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 1.5;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				controls.keys = [ 65, 83, 68 ];

				this.controls = controls;
				this.controls.addEventListener( 'change', this.render );

				// add event listeners to html for custom zooming and node selection.
                window.addEventListener( 'resize', this.onWindowResize.bind(this), false );
            }

			onWindowResize() {
				console.log("resizing")
				this.width = window.innerWidth;
				this.height = document.getElementById(this.dom_target).offsetHeight;

                this.camera.aspect = this.width / this.height;
                this.camera.lookAt(this.scene.position);
                this.camera.updateProjectionMatrix();
                this.renderer.setSize( this.width, this.height );
            }

            animate() {
                requestAnimationFrame( this.animate.bind(this) );
                this.controls.update();
                this.render();
            }

			//takes an object and adds it to the scene.
			add_object( object ){
				this.scene.add( object );
				console.log("added a new surface!")
			}

			print_scene(){
				console.log(this.scene);
			}
		}

		//draw a simple surface from a json imput containing the fields
		//x y and z.
		class simpleSurface{
			constructor(data, x = "x", y = "y", z = "z", color = "steelblue", wireframe = false){

				Array.prototype.unique = function() {
				    var arr = [];
				    for(var i = 0; i < this.length; i++) {
				        if(!arr.includes(this[i])) {
				            arr.push(this[i]);
				        }
				    }
				    return arr;
				}

				//grab some info about the data.
				this.x_range  = d3.extent(data, d => +d[x]);
				this.x_width  = this.x_range[1] - this.x_range[0];
				this.y_range  = d3.extent(data, d => +d[y]);
				this.y_width  = this.y_range[1] - this.y_range[0];
				this.z_range  = d3.extent(data, d => +d[z]);
				this.unique_x = data.map(d => +d[x]).unique().length;
				this.unique_y = data.map(d => +d[y]).unique().length;

				this.data = data;
				this.z = z; //so we know what to target in the data object later.


				this.make_geometry();
				this.make_material(color, wireframe);
				this.combine();
			}

			make_geometry(){
				// geometry of surface
				var geometry = new THREE.PlaneBufferGeometry(this.x_width, this.y_width,
					this.unique_x - 1, this.unique_y - 1 );

				//spits out an array of (x,y,z = 0) times the number of points we have.
				var vertices = geometry.attributes.position.array;

				//fill in the z coordinate with our data
				for ( var i = 0; i < this.data.length; i ++) vertices[(3*i) +2] = +this.data[i][this.z]*3;

				geometry.computeBoundingBox();
				this.zMin = geometry.boundingBox.min.z;
				this.zMax = geometry.boundingBox.max.z;
				this.zRange = this.zMax - this.zMin;
				this.geometry = geometry;
			}

			make_material(color, wireframe){
				var surface_color = new THREE.Color(color);
				//material of surface
				var material = new THREE.MeshPhongMaterial({
					   color: surface_color,
					   specular: 0x0,
					   shading: THREE.FlatShading,
					   side: THREE.DoubleSide,
					   wireframe:wireframe
				});
				this.material = material;
			}

			combine(){
				//put together geometry and material
				var mesh = new THREE.Mesh( this.geometry, this.material );

				//make an object and put our surface into it.
				this.surface_object = new THREE.Object3D();
				this.surface_object.add(mesh);
				this.surface_object.position.set(0,0,0); //might want to take this out.
				// scene.add( surface_object );
			}

			//function to return object when called for.
			object(){
				return this.surface_object;
			}
		}

		//set up the scene and append to the page
		var three_scene = new surface_scene("plot");

		d3.csv("data/knn_surface.csv", data => {
			//create a simple surface from our data and render it to our scene.
			var my_surface = new simpleSurface(data, x = "x", y = "y", z = "z", color = "steelblue", wireframe = false);

			//add the object to the scene.
			three_scene.add_object(my_surface.object())
		});

		d3.csv("data/bayes_surface.csv", data => {
			//create a simple surface from our data and render it to our scene.
			var my_surface = new simpleSurface(data, x = "x", y = "y", z = "z", color = "orangered", wireframe = true);

			//add the object to the scene.
			three_scene.add_object(my_surface.object())
		});

		// //end surface_scene
		// 	d3.csv("data/knn_surface.csv", data => {
		// 	// d3.csv("data/bayes_surface.csv", data => {
		//
		//
		// 		Array.prototype.unique = function() {
		// 		    var arr = [];
		// 		    for(var i = 0; i < this.length; i++) {
		// 		        if(!arr.includes(this[i])) {
		// 		            arr.push(this[i]);
		// 		        }
		// 		    }
		// 		    return arr;
		// 		}
		//
		// 		function linspace(a,b,length = 100){
		// 			var dist = b - a,
		// 				int_length = dist/length;
		//
		// 			return [...Array(length).keys()].map( i => a + i*int_length)
		// 		}
		//
		// 		var x_range = d3.extent(data, d => +d.x),
		// 			x_width = x_range[1] - x_range[0],
		// 			y_range = d3.extent(data, d => +d.y),
		// 			y_width = y_range[1] - y_range[0],
		// 			z_range = d3.extent(data, d => +d.z),
		// 			unique_x = data.map(d => +d.x).unique().length,
		// 			unique_y = data.map(d => +d.y).unique().length;
		//
		// 		// console.log("total_num =", data.length);
		//
		// 		if ( ! Detector.webgl ) {
		// 			Detector.addGetWebGLMessage();
		// 			document.getElementById( 'container' ).innerHTML = "";
		// 		}
		//
		// 		var container, stats;
		//
		// 		var camera, controls, scene, renderer;
		//
		// 		var mesh, texture;
		// 		var width = window.innerWidth,
		// 			height = window.innerHeight;
		//
		// 		var clock = new THREE.Clock();
		//
		// 		init();
		// 		animate();
		//
		// 		function init() {
		//
		// 			//==============================================================
		// 			//======== General three setup  ================================
		// 			//==============================================================
		// 			//document container
		// 			container = document.getElementById( 'container' );
		//
		// 			//Camera initialization
		// 			camera = new THREE.PerspectiveCamera( 60, width / height, 1, 1000 );
		// 	        camera.position.x = 0;
		// 	        camera.position.y = -8;
		// 	        camera.position.z = -4;
		//
		// 			//scene init
		// 			scene = new THREE.Scene();
		//
		// 			//Lights
		// 			var light1 = new THREE.PointLight(0xffffff);
		// 			light1.position.set(0,0,-100);
		// 			scene.add(light1);
		//
		// 			var light2 = new THREE.PointLight(0xffffff);
		// 			light2.position.set(0,0,100);
		// 			scene.add(light2);
		//
		// 			//Controls
		// 			controls = new THREE.OrbitControls( camera, container );
		// 			controls.addEventListener( 'change', render ); // remove when using animation loop
		//
		// 			//Set up the renderer
		// 			renderer = new THREE.WebGLRenderer();
		// 			renderer.setClearColor( 0xbfd1e5 );
		// 			renderer.setPixelRatio( window.devicePixelRatio );
		// 			renderer.setSize( width, height);
		// 			container.innerHTML = "";
		// 			//send to the container
		// 			container.appendChild( renderer.domElement );
		//
		// 			//FPS counter.
		// 			stats = new Stats();
		// 			container.appendChild( stats.dom );
		//
		// 			//Resize behavior.
		// 			window.addEventListener( 'resize', onWindowResize, false );
		//
		// 			//==============================================================
		// 			//======== Surface construction ================================
		// 			//==============================================================
		//
		// 			//geometry of surface
		// 			var geometry = new THREE.PlaneBufferGeometry(x_width, y_width, unique_x - 1, unique_y - 1 );
		//
		// 			//spits out an array of (x,y,z = 0) times the number of points we have.
		// 			var vertices = geometry.attributes.position.array;
		//
		// 			//fill in the z coordinate with our data
		// 			for ( var i = 0; i < data.length; i ++) vertices[(3*i) +2] = +data[i].z*3;
		//
		// 			geometry.computeBoundingBox();
		// 			var zMin = geometry.boundingBox.min.z;
		// 			var zMax = geometry.boundingBox.max.z;
		// 			var zRange = zMax - zMin;
		//
		// 			//material of surface
		// 			var material = new THREE.MeshPhongMaterial({
		// 				   color: 0xfeb24c,
		// 				   specular: 0x0,
		// 				   shading: THREE.FlatShading,
		// 				   side: THREE.DoubleSide,
		// 				   wireframe:false
		// 			});
		//
		// 			//put together geometry and material
		// 			mesh = new THREE.Mesh( geometry, material );
		//
		// 			//make an object and put our surface into it.
		// 			var surface_plot = new THREE.Object3D();
		// 			surface_plot.add(mesh);
		// 			surface_plot.position.set(0,0,0);
		// 			scene.add( surface_plot );
		//
		// 		}
		//
		// 		function onWindowResize() {
		//
		// 			camera.aspect = window.innerWidth / window.innerHeight;
		// 			camera.updateProjectionMatrix();
		//
		// 			renderer.setSize( window.innerWidth, window.innerHeight );
		// 		}
		//
		// 		function animate() {
		//
		// 			requestAnimationFrame( animate );
		//
		// 			controls.update();
		// 			// console.log(camera.position)
		// 			render();
		// 			stats.update();
		// 		}
		//
		// 		function render() {
		// 			renderer.render( scene, camera );
		// 		}
		// 	});


		</script>

	</body>
</html>
